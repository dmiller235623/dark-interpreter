* plan

send by 15th->pcbcartDONEawait PCBsARRIVED

1 phase: hardware switchingsDONE + architecture outlineROUGH 
2 phase: datagens/hardware tests BY BEGIN JAN!

3 phase: grains/audio buffers and processing (any mixing of signals?)
4 phase: knobs assigned and all tests/tweak/RELEASE

NOTE-==memory management/areas refresh==

3 blocks SRAM : 112KB + 16KB + 64KB (64 is ccmdata see delay code)

use 112KB+16 for general/96K sample buffer (1 second)

ccmdata for datagens/backwards/forwards

* TODO

- re-test new hardware/pcb/constructed TO TEST

- new hardware switches: 

switch audio input on/off via PC13 (pin 2) DONE TEST

40106 on TIM1_CH2 (pin 42) DONE/coded I think TEST

* MON 30 DEC

- MON/TUE:finish simulations(rossler,orbital, others), SIR and hodge.

SIR and co. as simulation/as equations...

notes:

- each cell has population which can travel/move across cells

SEIR model- number of pop of: suscept, exposed, infected, recovered

see: http://users.dickinson.edu/~siglej/131/materials/labs/lab03/handout.html

CAsDONE and hodge converted to cpus, hodge versionings: CA.c, hodge.c,
hodgenet.c, microbd hodge

but all needs larger cellspace...re-do leaky.c

- problem with all datagens as cpus is floats issue

- add wrap/limit and cellsize to each cpu if make full cell space

----

- added more ant code...

http://www.google.com/url?q=http://arxiv.org/pdf/1202.1639&sa=U&ei=xXXBUpq_K8jNswal3IHYDA&ved=0CDAQFjAD&usg=AFQjCNHLwRHZkmxORJkDZN0wwj7JnVvA3g

* FRI 27 DEC

- turmite and ant code added as CPUs to leaky.c (total now 14 CPUs)

- TODO add for datagens: CAs(2xone dim, life, two dim)DONE, 

working on hodge: microbd version, old hodge.c version, just found
version is hodgenet in sim. mod each so is just one line at a time...

//

- place all into datagens and resolve huge buffer question (perhaps
  that simulation-style datagens write history consecutively into
  working buffer but reserving first part for settings)

- war of "real" datagens/cpus

* THU 26 DEC

-knob->samplerate
-worm/ant as sample-er

:::leaky.c

- port all microbdDONE
- "real" redcodeDONE - still needs SPL!
- potential other stack based machines:

malbolge: converts all of memory first for interpreter so no-go
befunge: possible... http://en.wikipedia.org/wiki/Befunge DONE
stack1: http://www.ece.cmu.edu/~koopman/stack_computers/sec3_2.html#321 DONE

- differentiate cpus and other datagens? competing for buffers?
- stack code to add and subtract CPUs and bring into main code for ARM

* MON 23 DEC

- 1-stacks for grains/villagers 2-stacks for CPUS, mix, merge, leak each other

* WED 4 DEC

for stack machine/forth see:

http://www.ece.cmu.edu/~koopman/stack_computers/sec3_2.html#321

http://www.holmea.demon.co.uk/Mk1/Architecture.htm

BIOTA=befunge: http://en.wikipedia.org/wiki/Befunge

malbolge

* TUE 3 DEC

- decided just read buffer as 8 bit so no conversion and have uint_16t
  as limit of 655536 for working buffer which can also point into
  audio buffer

- how we deal with offset into working buffer for datagen settings

- have just audio and datagen/working buffer or 1,2,3 buffers
  audio,datagen results, working

- TODO: test NaN, fix biota and after that port all micro/BD code
  (make each microcoded/cpu as threaded (as is sample leaky stack code)

* MON 2 DEC

datagen work:

questions/TODO:

- will NaN from supercollider code crash ARM?
- 8/16bit (inline?) conversion code - buffer at end of codebuffer but if overlaps? 
- are datagens flexible enough in terms of use?

* notes in meantime

- list of chunks also as a stack which can be pushed and popped

- D.I text - projection/de quincey. site of execution is the
  skin. worm code and plague code becomes contagious on the skin...

see last old notebook notes

* MON 18 NOV notes


*PCB checklist:*

- still filter question! kind of resolved with extra cap!
- drcX
- non-connsX 
- eye checkX
- gnd and power/all analogue linesX
- sanity check of new changes+once over eyes/components/viasX
- check all layersX
- DRCX
- check size for dc socket/printX
- zonesX

- redo-eye-checkX
- punch viasX
- gerbers and check ORDERED

new PCB summarised for coding:

- switch audio input on/off via PC13 (pin 2)
- 40106 on TIM1_CH2 (pin 42)

* FRI 15 NOV TODO

-as below - trying filter resistor (was 33k replacing now with 100k)-
no great change -as below - 16bit->8bit when port instruction sets

try r11 as 100k seems improve somewhat

added optional cap next to r11 for filter (100n with 100k and 100k pwm for filter)

-finish/overview of PCB:

losing Nreset cap as was just debounce?

* WED 13 NOV TODO

- question of 8/16 bit translation for datagens

do we use a function to convert x buffer back and forth (not possible
for any size of buffer!)

- also if we have 3x datagens writing to same buffer - either do
  matrix with offsets into buffer or ....

- start to port supercollider datagensDONE-to test and tweak as
  questions are acceptable inputs and also how to reset _and_ some
  protection of locals in workingbuffer

- also how to use datagens eg.worms to steer grains or are these seperate?
all should be in workingbuffer so can be used...

- ringing filter mods 13700=r27 try as 100k

** notes on modes/movement

key as being mirror and freezing!

 x
x x finger direction grid depending on mode:
 x

1- code movement (how? does this work only for instruction sets?)
2- grain movement
3- movement through stored datagen/parameters
4- micro-macro levels
5- read/write buffer, storage buffer, flip-flop

* TUE 12 NOV TODO

- start datagens
- PCB as below

backwards/forwards through stored datagen space as general feature
(not of datagens)

say we have datagens 1,1,1 then we store just 1 ...

generic datagen 1,2,3 as three levels (also with different timing and
macro levels) and we assign real datagens to these 

then we have hardware matrix

- confusion as there are potentially 3 buffers: 1-audio,
  2-operating(though this can be also 1- or 3-), 3-back/forward
  datagen storage

- mirroring and doubling between these and datagens...

datagens remain as they are

* MON 11 NOV TODO

- re-test hardware knob and audio out FIXED so does not re-init

- add power socketDONE and check if can do simplified audio route for v
  basic D.I: DONE

these can be done with additional jumpers: on U2 4053:pins 12-14, on
10,11 on U3, next to incoming audio CHECK ALL

*working on REVISING2*

PCB CHECKLIST:

- new track widths for all audio/adc 0.5mmDONE
- look where we have xtal,pwm and I2S signals crossing audio/adcDONE

TODO- check new additions/changes
- ground plane AGND/DGND????
- any refinements to filter?-tests
- check&tidy/zonesandvias/re-checkall/SEND!

///

- assign parameters/knobs - mode knob, no. of grains and other macro settings

in length/cycle... out length?

one knob selects setting, other assigns setting (or 2 settings knob)

1-hardware assigned
2-param
3-assigned to setting
4-???
5-mode: how we distribute grains/overlap, micro/macro crossover

forwards/backwards/grid for datagen->filter/pwm

datagen->hardware

1,1,1
2,2,2
3,3,3
1,2,3
3,2,1
usw... how many=27 (cut down?)

- start on datagens/port from wormcode/new datagens/clean up

* FRI 8 NOV TODO

TEST:-- attempt to use new pin 42 and thin wire for new PWM tests (and
reconnect 40106) *WIRED

TIM1 CH2 - ?? *WORKING*

- now test all hardware options DONE

//

- test unhanging (and how works with top board)DONE and works well
  though could be more options of what to hang?

-  and re-hangDONE

- revising bottom design (see all notes below) + [bridge for optional
  3.3v powers 40106???]

///

[think on adding signal-> 40106 into filter clock?]

- brainstorm re-design//programming

// 

test audio->40106->clock of MAXIM filter

* THU 7 NOV TODO

- suddenly huge amp noise when we use 40106power... into LINEINR -
  fixed when shift TIM2 to TIM4 but shouldn't be issue for new 40106
  routing DONE (still some issues here...) UNSOLVED

- re-test with ADC DMA - no good/can use multiple in one go sans
  DMA? - have to set channel each timeDONE

- test all hardware options // one by one OKAY - though didn't test
  40106!

*1uF for incoming divider is better (CHANGE size on plans)* DONE

TODO: *larger caps on 40106 power* if that helps

Is PWM _or_ 40106 the problem as now no audio _with_ 40106 PWM (TIM4)?

- detached power from 40106 and R5 connection to lm358 and still have
(worse) noise problems

*-- can only attempt to use new pin 42 and thin wire for new PWM tests!*

//

- test unhanging (and how works with top board) and re-hang

- revising bottom design (see below) + finish and send


*knob notes:*

1-HW
2-macro/attachment for
3-datagen select
4-parameters for above datagen
5-application of datagen...???? grainsize somehow on micro/macro

+ 4 arrows ----> left/right code movement/speed... up/down as length sample????

* WED 6 NOV TODO

*new design notes:*

PC13 (pin 2) switches audio in!

TIM1 CH2 is for now 40106 PWM

//add caps/extra pads?/check&tidy/anydesignQ?/zonesandvias/re-checkall/SEND!

ground plane AGND/DGND????look where we have xtal,pwm and I2S signals crossing

TODO:

- test with ADC cap///single ADC

- re-test with ADC DMA 

- test new averaging scheme

- test all hardware options

- test unhanging (and how works with top board) and re-hang

My solution for STM ADC is: take 8 samples, get rid of the 2 highest
values and the 2 lowest values and average the 4 remaining

//- revising bottom design (see below)

*- datagen should also be tied to full hardware switch*

///

*STARTED with hardware switches but ADC jitter makes impossible or is
some other problem!*

Most noise is on AVDD:

Suggestions for re-design: 

- AVDD line thicker and clearer tracked
- moving AVDD filter closer to potis and AVDD chip

- AVDD cap/s(1Uf and 10nF) close to chip (between 12 and 13- VDDA and VSSA) 

(c21 and c13 should be closer to chip)

- AVDD caps close to potis or at least around and about

+ see other design notes(fix pwm, fix input bias), lose poti strips,
  make bottom less symmetrical...

///TODO:

see if can insert 100n close to AVDD for testing?DONE and works better

test chip caps (soldering), 40106?(remove/check) NOT DONE!

how much in software can be done - slow down, averaging? RECHECK

//THOUGHTS->

- how we can simplify, less touch points and reduce to one board??? OR NOT???

PROs: reduce filter crap and parts count (not so much-could lose
4053), lose top connector, not so much hanging


* TUE 5 NOV TODO

- to easily try with other 4066? or do we need to bias incoming and if
  so where?

other hc4066 works but only biasing audio->cap->resistor divider works

could also use U6 extra pins...

bias where we have feedback label straight on jack

gets rid of all bleed on input!! (in 4053 and other)

- test pulse _and_ width for LM13700 DONE

///

- clean up hardware switches drastically TODO - but it works

*STARTED with hardware switches but ADC jitter makes impossible or is
some other problem!*

- if we just have hardware switches to poti as all switch binary options
  very simply mapped to pins (what if all on say? or rather reduce options)

but then also option to untie all clocks and to untie switches themselves

-untie each/all switches (total 10 bits)
-untie each/all clocks // in parallel to untie all switches _and_ all switch options (3 bits)
-tie each datagen to each clock (3 x 3 =4 bits???)
-bitwise for switches (10 bits) - somehow with untied
-which datagen determines whole set of bits for above (ie. all switches)

a switch can be on/off/untied/datagen tied(and which of say 3)? = 6 states = 3 bits

so 30 bits switches+4clocks=34! so needs be simplified by re-mapping

eg. some bits only if filter is on make sense

//note also filter can be detached on one side so leftaudio goes ONLY to filterin

///

* MON 4 NOV TODO:

where is map of pads? ON WALL!

how many bits is ADC? 12 bits = 0->4096

what should LM13700 PWM be like? 39KHz? check! - replaced routine with
same as maxim - to be cleaned up!

to test fingers/potis - fingers done...TESTED WORKING

poti fingers - some effects on top board but not on bottom as no
generators

///

*problems are:*

- bleedthrough 4053, 4066 (what if was replaced with non HCT - check
  resistance - will it switch?)

- we can't cut input signal out of loop // re-test if feedback somehow
  does this? NO - but can still keep as option

- ringing in the filter - maybe change PWM timing? TEST

*otherwise*

1-all hardware switches working

////

hardware:

- is feedback bleed so bad when we have signal? YES!

also problem is how to cut feedback from justin (as we have this on 4053)

so leave feedback for now and do some of this in software...

- testing feedbackX, LM358 - main signal bleeds also through 

- test EEG signals:

no results: bad solder (redone), bad design (recheck - checked),

remade all and now works??? is in adc_buffer[9[]

- how avoid filter ringing? look at filter signal path (re-solder all also) DONE

coding:

* working notes

audio.c hardware.c mainbuffer.c datagen.c

with headers...


* issues

- audio bleed is through 4066 feedback switch (even when off - perhaps
  add resistor to signal path (pin 2) - TEST! - with 10k is very
  minimal bleed

what we've done is added 20k from pin 12 of 4053 to pin 2 of 4066
(detached from pcb) to insert 20k in path from JACK in (but would need
to change design so for first 10 leave without feedback path!)

- power consumption seems high? TEST THIS

- some issues with ringing of lm13700 in filter feedback path

- also 

* programming

: PATH=~/sat/bin:$PATH
: PATH=~/stm32f4/stlink/flash:$PATH

: make stlink_flash

connection on own board is VDD, SCLCK, SWDIO, GND (so last 2 are
swapped from STLINK board)

* TODO:

0- all code structure with headersDONE

1-audio codec/left and rightDONE

2-hardware switchesDONE

2.5-test audio in/out straight DONE but 4053 seems not quite right RETEST. FIXED

2.6 get knobs and touch sensors in TO TEST. TESTED ADC0 (2nd knob
down) TEST TOUCH (lower and top)DONE

4-PWM/interrupts TO TEST nearly DONE

4.5-fingers//EEG//LM358IN DONE

///


5-filter and all hardware switches nearly DONE

5.6-buffer treatment tests/ideas.

6-datagens - backwards, code chunks, symmetry, code direction and
recoding/rechunking

(read from lists of grain size and position, what to do if fill buffer
part way through grain?)

7-stack/frame -> stack machine in buffer

8-final tests and release

* code notes

- micro-macro slider/control for all ops.

grains as villagers/following instructions +read/write head

-plague village/turing tape combination.  -random walk through
code/sample space. swapping those 2 buffers(past/future)... fingers
select code movements

perhaps some kind of succession of read/write/code buffers with
grainsize as process...

various mapped movements through these buffers

and also finger as code movement - let's say 4 directions, a kind of
cross controller., but also fingers or some way of activating a matrix
signal path (through buffers, through distortion and feedback)

also control speed/playback

-an architecture/x buffers are switchable

-some way of using fft//grains as villagers

-grains as multiple executable threads

- xread/write/instruction pointer

- revisit promiscuous

- multiple threads which share stack/registers/memory space but which
  have seperate code/cpu identity and/or have leaky stacks

** software filters

moog voltage controlled lowpass filter of 4th order from http://www.musicdsp.org 

see also: http://www.kvraudio.com/forum/viewtopic.php?p=5184160


** code

./audio.h:13:#define BUFF_LEN 128 /2 for stereo=64

48000 samples per second = 750 buffs per second

yes looks like. how to adapt to write/read individual locations from large buffer

-is 64 our smallest grain size or do we change this?
-array of sample locations for each sample (generated by main code)

- big buffer or 3x buffer
- macro-micro
- port micro-bd/wormcode
- note 3 blocks SRAM : 112KB + 16KB + 64KB (64 is ccmdata see delay code)

** notes from notebook

- all pads should be enabled (hardware knob)
- concentric code lines (grain, buffer, time)
- turing machine
- contagion back/forwards in time - time axis manipulation
- de quincey texts
- micro/macro code and grain chunks - grains ordered//chunks ordered
- code chunks shifted by hand
- villagers/grains/barriers/walls

assembly of code chunks...

datagens: number of data returned, buffer, step-size, direction

algos=supercollider, micro+BD, isometric worms

knobs:

1-hardware/filter switches**
2-speed/stepsize
3,4-datagen for each macro level
5 macro level, direction.

or writegen/readgen on knobs

code movement on pads

** questions

- how many bits is audio codec set to?

16 bits so at 48k we have 96k samples per second = around 1 sec

at 8k we have 6 sec... TO DECIDE (can also cut down bits)

- how to work on micro-macro levels for code and grains/villagers

- how and where barriers are installed...

- do we work with 64 as lowest chunk size (or lower in
  chunklist/writeloc approach or hardwired)

this should be set as BUFF_LEN in:

I2S_Block_PlayRec((uint32_t)&tx_buffer, (uint32_t)&rx_buffer, BUFF_LEN);

** buffer question

1-

macro as list of grains/villagers which can be moved (by hand) read/write

(but how many, general size?)

micro as manipulation of buffer itself/churn (how?)

and how this translates into chunk for callback

2- what is worm/BD model???

- interrupt at samplerate reads/writes sample at read/write points
  determined async by algorithms and outputs sample/mix (of read/write
  pointer)

** further/code gens

[[file:latestresearch/sc3-plugins-src-2012-05-26/source/SLUGens/SLUGens.cpp::void%20FitzHughNagumo_next_k%20FitzHughNagumo%20unit%20int%20inNumSamples]]

http://doc.sccode.org/Classes/FitzHughNagumo.html

also Oregonator (reaction.diff), brusselator...

Patterson's worms...
