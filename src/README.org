* plan

1 phase: hardware switchings + architecture outline 
2 phase: datagens
3 phase: audio buffers and processing (any mixing of signals?)


NOTE-==memory management/areas refresh==

3 blocks SRAM : 112KB + 16KB + 64KB (64 is ccmdata see delay code)

use 112KB+16 for general/96K sample buffer (1 second)

ccmdata for datagens/backwards/forwards

* WED 6 NOV TODO

- re-test with ADC DMA and test all hardware options
- test unhanging (and how works with top board) and re-hang
- revising bottom design (see below)

*- datagen should also be tied to full hardware switch*

///

*STARTED with hardware switches but ADC jitter makes impossible or is
some other problem!*

Most noise is on AVDD:

Suggestions for re-design: 

- AVDD line thicker and clearer tracked
- moving AVDD filter closer to potis and AVDD chip

- AVDD cap/s(1Uf and 10nF) close to chip (between 12 and 13- VDDA and VSSA) 

(c21 and c13 should be closer to chip)

- AVDD caps close to potis or at least around and about

+ see other design notes(fix pwm, fix input bias), lose poti strips,
  make bottom less symmetrical...

///TODO:

see if can insert 100n close to AVDD for testing?DONE and works better

test chip caps (soldering), 40106?(remove/check) NOT DONE!

how much in software can be done - slow down, averaging? RECHECK

//THOUGHTS->

- how we can simplify, less touch points and reduce to one board??? OR NOT???

PROs: reduce filter crap and parts count (not so much-could lose
4053), lose top connector, not so much hanging


* TUE 5 NOV TODO

- to easily try with other 4066? or do we need to bias incoming and if
  so where?

other hc4066 works but only biasing audio->cap->resistor divider works

could also use U6 extra pins...

bias where we have feedback label straight on jack

gets rid of all bleed on input!! (in 4053 and other)

- test pulse _and_ width for LM13700 DONE

///

- clean up hardware switches drastically TODO - but it works

*STARTED with hardware switches but ADC jitter makes impossible or is
some other problem!*

- if we just have hardware switches to poti as all switch binary options
  very simply mapped to pins (what if all on say? or rather reduce options)

but then also option to untie all clocks and to untie switches themselves

-untie each/all switches (total 10 bits)
-untie each/all clocks // in parallel to untie all switches _and_ all switch options (3 bits)
-tie each datagen to each clock (3 x 3 =4 bits???)
-bitwise for switches (10 bits) - somehow with untied
-which datagen determines whole set of bits for above (ie. all switches)

a switch can be on/off/untied/datagen tied(and which of say 3)? = 6 states = 3 bits

so 30 bits switches+4clocks=34! so needs be simplified by re-mapping

eg. some bits only if filter is on make sense

//note also filter can be detached on one side so leftaudio goes ONLY to filterin

///

* MON 4 NOV TODO:

where is map of pads? ON WALL!

how many bits is ADC? 12 bits = 0->4096

what should LM13700 PWM be like? 39KHz? check! - replaced routine with
same as maxim - to be cleaned up!

to test fingers/potis - fingers done...TESTED WORKING

poti fingers - some effects on top board but not on bottom as no
generators

///

*problems are:*

- bleedthrough 4053, 4066 (what if was replaced with non HCT - check
  resistance - will it switch?)

- we can't cut input signal out of loop // re-test if feedback somehow
  does this? NO - but can still keep as option

- ringing in the filter - maybe change PWM timing? TEST

*otherwise*

1-all hardware switches working

////

hardware:

- is feedback bleed so bad when we have signal? YES!

also problem is how to cut feedback from justin (as we have this on 4053)

so leave feedback for now and do some of this in software...

- testing feedbackX, LM358 - main signal bleeds also through 

- test EEG signals:

no results: bad solder (redone), bad design (recheck - checked),

remade all and now works??? is in adc_buffer[9[]

- how avoid filter ringing? look at filter signal path (re-solder all also) DONE

coding:

* working notes

audio.c hardware.c mainbuffer.c datagen.c

with headers...


* issues

- audio bleed is through 4066 feedback switch (even when off - perhaps
  add resistor to signal path (pin 2) - TEST! - with 10k is very
  minimal bleed

what we've done is added 20k from pin 12 of 4053 to pin 2 of 4066
(detached from pcb) to insert 20k in path from JACK in (but would need
to change design so for first 10 leave without feedback path!)

- power consumption seems high? TEST THIS

- some issues with ringing of lm13700 in filter feedback path

- also 

* programming

: PATH=~/sat/bin:$PATH
: PATH=~/stm32f4/stlink/flash:$PATH

: make stlink_flash

connection on own board is VDD, SCLCK, SWDIO, GND (so last 2 are
swapped from STLINK board)

* TODO:

0- all code structure with headersDONE

1-audio codec/left and rightDONE

2-hardware switchesDONE

2.5-test audio in/out straight DONE but 4053 seems not quite right RETEST. FIXED

2.6 get knobs and touch sensors in TO TEST. TESTED ADC0 (2nd knob
down) TEST TOUCH (lower and top)DONE

4-PWM/interrupts TO TEST nearly DONE

4.5-fingers//EEG//LM358IN DONE

///


5-filter and all hardware switches nearly DONE

5.6-buffer treatment tests/ideas.

6-datagens - backwards, code chunks, symmetry, code direction and
recoding/rechunking

(read from lists of grain size and position, what to do if fill buffer
part way through grain?)

7-stack/frame -> stack machine in buffer

8-final tests and release

* code notes

- micro-macro slider/control for all ops.

grains as villagers/following instructions +read/write head

-plague village/turing tape combination.  -random walk through
code/sample space. swapping those 2 buffers(past/future)... fingers
select code movements

perhaps some kind of succession of read/write/code buffers with
grainsize as process...

various mapped movements through these buffers

and also finger as code movement - let's say 4 directions, a kind of
cross controller., but also fingers or some way of activating a matrix
signal path (through buffers, through distortion and feedback)

also control speed/playback

-an architecture/x buffers are switchable

-some way of using fft//grains as villagers

-grains as multiple executable threads

- xread/write/instruction pointer

- revisit promiscuous

- multiple threads which share stack/registers/memory space but which
  have seperate code/cpu identity and/or have leaky stacks

** software filters

moog voltage controlled lowpass filter of 4th order from http://www.musicdsp.org 

see also: http://www.kvraudio.com/forum/viewtopic.php?p=5184160


** code

./audio.h:13:#define BUFF_LEN 128 /2 for stereo=64

48000 samples per second = 750 buffs per second

yes looks like. how to adapt to write/read individual locations from large buffer

-is 64 our smallest grain size or do we change this?
-array of sample locations for each sample (generated by main code)

- big buffer or 3x buffer
- macro-micro
- port micro-bd/wormcode
- note 3 blocks SRAM : 112KB + 16KB + 64KB (64 is ccmdata see delay code)

** notes from notebook

- all pads should be enabled (hardware knob)
- concentric code lines (grain, buffer, time)
- turing machine
- contagion back/forwards in time - time axis manipulation
- de quincey texts
- micro/macro code and grain chunks - grains ordered//chunks ordered
- code chunks shifted by hand
- villagers/grains/barriers/walls

assembly of code chunks...

datagens: number of data returned, buffer, step-size, direction

algos=supercollider, micro+BD, isometric worms

knobs:

1-hardware/filter switches**
2-speed/stepsize
3,4-datagen for each macro level
5 macro level, direction.

or writegen/readgen on knobs

code movement on pads

** questions

- how many bits is audio codec set to?

16 bits so at 48k we have 96k samples per second = around 1 sec

at 8k we have 6 sec... TO DECIDE (can also cut down bits)

- how to work on micro-macro levels for code and grains/villagers

- how and where barriers are installed...

- do we work with 64 as lowest chunk size (or lower in
  chunklist/writeloc approach or hardwired)

this should be set as BUFF_LEN in:

I2S_Block_PlayRec((uint32_t)&tx_buffer, (uint32_t)&rx_buffer, BUFF_LEN);

** buffer question

1-

macro as list of grains/villagers which can be moved (by hand) read/write

(but how many, general size?)

micro as manipulation of buffer itself/churn (how?)

and how this translates into chunk for callback

2- what is worm/BD model???

- interrupt at samplerate reads/writes sample at read/write points
  determined async by algorithms and outputs sample/mix (of read/write
  pointer)

** further/code gens

[[file:latestresearch/sc3-plugins-src-2012-05-26/source/SLUGens/SLUGens.cpp::void%20FitzHughNagumo_next_k%20FitzHughNagumo%20unit%20int%20inNumSamples]]

http://doc.sccode.org/Classes/FitzHughNagumo.html

also Oregonator (reaction.diff), brusselator...

Patterson's worms...
