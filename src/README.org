* TUE 5 NOV TODO

* MON 4 NOV TODO:

where is map of pads? ON WALL!

how many bits is ADC? 12 bits = 0->4096

what should LM13700 PWM be like? 39KHz? check! - replaced routine with
same as maxim - to be cleaned up!

to test fingers/potis - fingers done...TESTED WORKING

poti fingers - some effects on top board but not on bottom as no
generators

///

*problems are:*

- bleedthrough 4053, 4066 (what if was replaced with non HCT - check
  resistance - will it switch?)

- we can't cut input signal out of loop // re-test if feedback somehow
  does this? NO - but can still keep as option

- ringing in the filter - maybe change PWM timing? TEST

*otherwise*

1-all hardware switches working

////

hardware:

- is feedback bleed so bad when we have signal? YES!

also problem is how to cut feedback from justin (as we have this on 4053)

so leave feedback for now and do some of this in software...

- testing feedbackX, LM358 - main signal bleeds also through 

- test EEG signals:

no results: bad solder (redone), bad design (recheck - checked),

remade all and now works??? is in adc_buffer[9[]

- how avoid filter ringing? look at filter signal path (re-solder all also) DONE

coding:

* working notes

audio.c hardware.c mainbuffer.c datagen.c

with headers...


* issues

- audio bleed is through 4066 feedback switch (even when off - perhaps
  add resistor to signal path (pin 2) - TEST! - with 10k is very
  minimal bleed

what we've done is added 20k from pin 12 of 4053 to pin 2 of 4066
(detached from pcb) to insert 20k in path from JACK in (but would need
to change design so for first 10 leave without feedback path!)

- power consumption seems high? TEST THIS

- some issues with ringing of lm13700 in filter feedback path

- also 

* programming

: PATH=~/sat/bin:$PATH
: PATH=~/stm32f4/stlink/flash:$PATH

: make stlink_flash

connection on own board is VDD, SCLCK, SWDIO, GND (so last 2 are
swapped from STLINK board)

* TODO:

0- all code structure with headersDONE

1-audio codec/left and rightDONE

2-hardware switchesDONE

2.5-test audio in/out straight DONE but 4053 seems not quite right RETEST. FIXED

2.6 get knobs and touch sensors in TO TEST. TESTED ADC0 (2nd knob
down) TEST TOUCH (lower and top)

4-PWM/interrupts TO TEST nearly DONE

5-filter and all hardware switches nearly DONE

5.5-fingers//EEG//LM358IN 

///

5.6-buffer treatment tests/ideas.

6-datagens - backwards, code chunks, symmetry, code direction and
recoding/rechunking

(read from lists of grain size and position, what to do if fill buffer
part way through grain?)

7-stack/frame -> stack machine in buffer

8-final tests and release

* code notes

- micro-macro slider/control for all ops.

grains as villagers/following instructions +read/write head

-plague village/turing tape combination.  -random walk through
code/sample space. swapping those 2 buffers(past/future)... fingers
select code movements

perhaps some kind of succession of read/write/code buffers with
grainsize as process...

various mapped movements through these buffers

and also finger as code movement - let's say 4 directions, a kind of
cross controller., but also fingers or some way of activating a matrix
signal path (through buffers, through distortion and feedback)

also control speed/playback

-an architecture/x buffers are switchable

-some way of using fft//grains as villagers

-grains as multiple executable threads

- xread/write/instruction pointer

- revisit promiscuous

- multiple threads which share stack/registers/memory space but which
  have seperate code/cpu identity and/or have leaky stacks

** software filters

moog voltage controlled lowpass filter of 4th order from http://www.musicdsp.org 

see also: http://www.kvraudio.com/forum/viewtopic.php?p=5184160


** code

./audio.h:13:#define BUFF_LEN 128 /2 for stereo=64

48000 samples per second = 750 buffs per second

yes looks like. how to adapt to write/read individual locations from large buffer

-is 64 our smallest grain size or do we change this?
-array of sample locations for each sample (generated by main code)

- big buffer or 3x buffer
- macro-micro
- port micro-bd/wormcode
- note 3 blocks SRAM : 112KB + 16KB + 64KB (64 is ccmdata see delay code)

** notes from notebook

- all pads should be enabled (hardware knob)
- concentric code lines (grain, buffer, time)
- turing machine
- contagion back/forwards in time - time axis manipulation
- de quincey texts
- micro/macro code and grain chunks - grains ordered//chunks ordered
- code chunks shifted by hand
- villagers/grains/barriers/walls

assembly of code chunks...

datagens: number of data returned, buffer, step-size, direction

algos=supercollider, micro+BD, isometric worms

knobs:

1-hardware/filter switches**
2-speed/stepsize
3,4-datagen for each macro level
5 macro level, direction.

or writegen/readgen on knobs

code movement on pads

** questions

- how many bits is audio codec set to?

16 bits so at 48k we have 96k samples per second = around 1 sec

at 8k we have 6 sec... TO DECIDE (can also cut down bits)

- how to work on micro-macro levels for code and grains/villagers

- how and where barriers are installed...

- do we work with 64 as lowest chunk size (or lower in
  chunklist/writeloc approach or hardwired)

this should be set as BUFF_LEN in:

I2S_Block_PlayRec((uint32_t)&tx_buffer, (uint32_t)&rx_buffer, BUFF_LEN);

** buffer question

1-

macro as list of grains/villagers which can be moved (by hand) read/write

(but how many, general size?)

micro as manipulation of buffer itself/churn (how?)

and how this translates into chunk for callback

2- what is worm/BD model???

- interrupt at samplerate reads/writes sample at read/write points
  determined async by algorithms and outputs sample/mix (of read/write
  pointer)

** further/code gens

[[file:latestresearch/sc3-plugins-src-2012-05-26/source/SLUGens/SLUGens.cpp::void%20FitzHughNagumo_next_k%20FitzHughNagumo%20unit%20int%20inNumSamples]]

http://doc.sccode.org/Classes/FitzHughNagumo.html

also Oregonator (reaction.diff), brusselator...

Patterson's worms...
