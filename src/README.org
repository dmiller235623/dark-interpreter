* working notes

audio.c hardware.c mainbuffer.c datagen.c

with headers...

* programming

: PATH=~/sat/bin:$PATH
: PATH=~/stm32f4/stlink/flash:$PATH

: make stlink_flash

connection on own board is VDD, SCLCK, SWDIO, GND (so last 2 are
swapped from STLINK board)

* TODO:

0- all code structure with headersDONE

1-audio codec/left and rightDONE

2-hardware switchesDONE

2.5-test audio in/out straight DONE but 4053 seems not quite right RETEST. FIXED

2.6 get knobs and touch sensors in TO TEST. TESTED ADC0 (2nd knob
down) TEST TOUCH (lower and top)

4-PWM TO TEST

5-filter and all hardware switches

6-datagens - backwards, code chunks, symmetry, code direction and
recoding/rechunking

3-buffer treatment tests/ideas.

(read from lists of grain size and position, what to do if fill buffer
part way through grain?)

7-stack/frame -> stack machine in buffer

8-fingers//EEG//LM358IN

* older code notes

- micro-macro slider/control for all ops.

grains as villagers/following instructions +read/write head

-plague village/turing tape combination.  -random walk through
code/sample space. swapping those 2 buffers(past/future)... fingers
select code movements

perhaps some kind of succession of read/write/code buffers with
grainsize as process...

various mapped movements through these buffers

and also finger as code movement - let's say 4 directions, a kind of
cross controller., but also fingers or some way of activating a matrix
signal path (through buffers, through distortion and feedback)

also control speed/playback

-an architecture/x buffers are switchable

-some way of using fft//grains as villagers

-grains as multiple executable threads

- xread/write/instruction pointer

- revisit promiscuous

- multiple threads which share stack/registers/memory space but which
  have seperate code/cpu identity and/or have leaky stacks

** software filters

moog voltage controlled lowpass filter of 4th order from http://www.musicdsp.org 

see also: http://www.kvraudio.com/forum/viewtopic.php?p=5184160


** code

./audio.h:13:#define BUFF_LEN 128 /2 for stereo=64

48000 samples per second = 750 buffs per second

yes looks like. how to adapt to write/read individual locations from large buffer

-is 64 our smallest grain size or do we change this?
-array of sample locations for each sample (generated by main code)

- big buffer or 3x buffer
- macro-micro
- port micro-bd/wormcode
- note 3 blocks SRAM : 112KB + 16KB + 64KB (64 is ccmdata see delay code)

** notes from notebook

- all pads should be enabled (hardware knob)
- concentric code lines (grain, buffer, time)
- turing machine
- contagion back/forwards in time - time axis manipulation
- de quincey texts
- micro/macro code and grain chunks - grains ordered//chunks ordered
- code chunks shifted by hand
- villagers/grains/barriers/walls

assembly of code chunks...

datagens: number of data returned, buffer, step-size, direction

algos=supercollider, micro+BD, isometric worms

knobs:

1-hardware/filter switches**
2-speed/stepsize
3,4-datagen for each macro level
5 macro level, direction.

or writegen/readgen on knobs

code movement on pads

** questions

- how many bits is audio codec set to?

16 bits so at 48k we have 96k samples per second = around 1 sec

at 8k we have 6 sec... TO DECIDE (can also cut down bits)

- how to work on micro-macro levels for code and grains/villagers

- how and where barriers are installed...

- do we work with 64 as lowest chunk size (or lower in
  chunklist/writeloc approach or hardwired)

this should be set as BUFF_LEN in:

I2S_Block_PlayRec((uint32_t)&tx_buffer, (uint32_t)&rx_buffer, BUFF_LEN);

** buffer question

1-

macro as list of grains/villagers which can be moved (by hand) read/write

(but how many, general size?)

micro as manipulation of buffer itself/churn (how?)

and how this translates into chunk for callback

2- what is worm/BD model???

- interrupt at samplerate reads/writes sample at read/write points
  determined async by algorithms and outputs sample/mix (of read/write
  pointer)


** further/code gens

[[file:latestresearch/sc3-plugins-src-2012-05-26/source/SLUGens/SLUGens.cpp::void%20FitzHughNagumo_next_k%20FitzHughNagumo%20unit%20int%20inNumSamples]]

http://doc.sccode.org/Classes/FitzHughNagumo.html

also Oregonator (reaction.diff), brusselator...
